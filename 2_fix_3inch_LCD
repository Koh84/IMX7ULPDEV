to start adapting for mipi lcd, follow the following steps,

1. identify which LCD controller you using, this is ST7701 for us
2. ask the manufacturer for what to write to these registers in order to make it work
3. then, go to uboot-imx/drivers/video/hx8363_wvga.c, do the following changes

-
+#define DEBUG
 #include <common.h>
 #include <mipi_dsi_northwest.h>
 #include <mipi_display.h>
 #define TC358763_DCS_write_1A_3P(addr, ...)	\
 	TC358763_DCS_write_1A_nP(3, addr, __VA_ARGS__)
 
+#define TC358763_DCS_write_1A_4P(addr, ...)	\
+	TC358763_DCS_write_1A_nP(4, addr, __VA_ARGS__)
+
 #define TC358763_DCS_write_1A_5P(addr, ...)	\
 	TC358763_DCS_write_1A_nP(5, addr, __VA_ARGS__)
 
 #define TC358763_DCS_write_1A_7P(addr, ...)	\
 	TC358763_DCS_write_1A_nP(7, addr, __VA_ARGS__)
 
+#define TC358763_DCS_write_1A_9P(addr, ...)	\
+	TC358763_DCS_write_1A_nP(9, addr, __VA_ARGS__)
+
+#define TC358763_DCS_write_1A_11P(addr, ...)	\
+	TC358763_DCS_write_1A_nP(11, addr, __VA_ARGS__)
+
+
 #define TC358763_DCS_write_1A_12P(addr, ...)	\
 	TC358763_DCS_write_1A_nP(12, addr, __VA_ARGS__)
 
 #define TC358763_DCS_write_1A_14P(addr, ...)	\
 	TC358763_DCS_write_1A_nP(14, addr, __VA_ARGS__)
 
+#define TC358763_DCS_write_1A_16P(addr, ...)	\
+	TC358763_DCS_write_1A_nP(16, addr, __VA_ARGS__)
+
 #define TC358763_DCS_write_1A_19P(addr, ...)	\
 	TC358763_DCS_write_1A_nP(19, addr, __VA_ARGS__)
 
 
 	debug("MIPI DSI LCD HX8363 setup.\n");
 
-	TC358763_DCS_write_1A_3P(0xB9, 0xFF, 0x83, 0x63);/* SET password */
-
-	TC358763_DCS_write_1A_19P(0xB1, 0x01, 0x00, 0x44, 0x08, 0x01, 0x10, 0x10, 0x36,
-				  0x3E, 0x1A, 0x1A, 0x40, 0x12, 0x00, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6);/* Set Power */
-	TC358763_DCS_write_1A_2P(0xB2, 0x08, 0x03);/* Set DISP */
-	TC358763_DCS_write_1A_7P(0xB4, 0x02, 0x18, 0x9C, 0x08, 0x18, 0x04, 0x6C);
-	TC358763_DCS_write_1A_1P(0xB6, 0x00);/* Set VCOM */
-	TC358763_DCS_write_1A_1P(0xCC, 0x0B);/* Set Panel */
-	TC358763_DCS_write_1A_34P(0xE0, 0x0E, 0x15, 0x19, 0x30, 0x31, 0x3F, 0x27, 0x3C, 0x88, 0x8F, 0xD1, 0xD5, 0xD7, 0x16, 0x16,
-				  0x0C, 0x1E, 0x0E, 0x15, 0x19, 0x30, 0x31, 0x3F, 0x27, 0x3C, 0x88, 0x8F,
-				  0xD1, 0xD5, 0xD7, 0x16, 0x16, 0x0C, 0x1E);
-	mdelay(5);
-
-	TC358763_DCS_write_1A_1P(0x3A, 0x77);/* 24bit */
-	TC358763_DCS_write_1A_14P(0xBA, 0x11, 0x00, 0x56, 0xC6, 0x10, 0x89, 0xFF, 0x0F, 0x32, 0x6E, 0x04, 0x07, 0x9A, 0x92);
-	TC358763_DCS_write_1A_0P(0x21);
-
+	TC358763_DCS_write_1A_5P(0xFF,0x77,0x01,0x00,0x00,0x13);
+	TC358763_DCS_write_1A_2P(0xE8,0x00,0x0E);
+	TC358763_DCS_write_1A_5P(0xFF,0x77,0x01,0x00,0x00,0x00);
 	TC358763_DCS_write_1A_0P(0x11);
+	mdelay(120);
+	TC358763_DCS_write_1A_5P(0xFF,0x77,0x01,0x00,0x00,0x13);
+	TC358763_DCS_write_1A_2P(0xE8,0x00,0x0C);
 	mdelay(10);
-
+	TC358763_DCS_write_1A_2P(0xE8,0x00,0x00);
+	TC358763_DCS_write_1A_5P(0xFF,0x77,0x01,0x00,0x00,0x00);
+	TC358763_DCS_write_1A_5P(0xFF,0x77,0x01,0x00,0x00,0x10);
+	TC358763_DCS_write_1A_2P(0xC0,0x4F,0x00);
+	TC358763_DCS_write_1A_2P(0xC1,0x07,0x02);
+	TC358763_DCS_write_1A_2P(0xC2,0x31,0x05);
+	TC358763_DCS_write_1A_1P(0xC6,0x01);
+	TC358763_DCS_write_1A_1P(0xCC,0x38);
+	TC358763_DCS_write_1A_16P(0xB0,0x00,0x0A,0x11,0x0C,0x10,0x05,0x00,0x08,0x08,0x1F,0x07,0x13,0x10,0xA9,0x30,0x18);
+	TC358763_DCS_write_1A_16P(0xB1,0x00,0x0B,0x11,0x0D,0x0F,0x05,0x02,0x07,0x06,0x20,0x05,0x15,0x13,0xA9,0x30,0x18);
+	TC358763_DCS_write_1A_5P(0xFF,0x77,0x01,0x00,0x00,0x11);
+	TC358763_DCS_write_1A_1P(0xB0,0x53);
+	TC358763_DCS_write_1A_1P(0xB1,0x60);
+	TC358763_DCS_write_1A_1P(0xB2,0x87);
+	TC358763_DCS_write_1A_1P(0xB3,0x80);
+	TC358763_DCS_write_1A_1P(0xB5,0x49);
+	TC358763_DCS_write_1A_1P(0xB7,0x85);
+	TC358763_DCS_write_1A_1P(0xB8,0x21);
+	TC358763_DCS_write_1A_1P(0xC1,0x78);
+	TC358763_DCS_write_1A_1P(0xC2,0x78);
+	mdelay(100);
+
+	TC358763_DCS_write_1A_3P(0xE0,0x00,0x00,0x02);
+	TC358763_DCS_write_1A_11P(0xE1,0x03,0xA0,0x00,0x00,0x02,0xA0,0x00,0x00,0x00,0x33,0x33);
+	TC358763_DCS_write_1A_12P(0xE2,0x22,0x22,0x33,0x33,0x88,0xA0,0x00,0x00,0x87,0xA0,0x00,0x00);
+	TC358763_DCS_write_1A_4P(0xE3,0x00,0x00,0x22,0x22);
+	TC358763_DCS_write_1A_2P(0xE4,0x44,0x44);
+	TC358763_DCS_write_1A_16P(0xE5,0x04,0x84,0xA0,0xA0,0x06,0x86,0xA0,0xA0,0x08,0x88,0xA0,0xA0,0x0A,0x8A,0xA0,0xA0);
+	TC358763_DCS_write_1A_4P(0xE6,0x00,0x00,0x22,0x22);
+	TC358763_DCS_write_1A_2P(0xE7,0x44,0x44);
+	TC358763_DCS_write_1A_16P(0xE8,0x03,0x83,0xA0,0xA0,0x05,0x86,0xA0,0xA0,0x07,0x87,0xA0,0xA0,0x09,0x89,0xA0,0xA0);
+	TC358763_DCS_write_1A_7P(0xEB,0x00,0x01,0xE4,0xE4,0x88,0x00,0x40);
+	TC358763_DCS_write_1A_2P(0xEC,0x3C,0x01);
+	TC358763_DCS_write_1A_16P(0xED,0xAB,0x89,0x76,0x54,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x20,0x45,0x67,0x98,0xBA);
+	TC358763_DCS_write_1A_6P(0xEF,0x08,0x08,0x08,0x08,0x3F,0x1F);
+	TC358763_DCS_write_1A_5P(0xFF,0x77,0x01,0x00,0x00,0x00);
+	mdelay(20);
 	TC358763_DCS_write_1A_0P(0x29);
-	mdelay(120);
+
+
 
 	return 0;
 }


4. then, go to kernel_imx/drivers/video/fbdev/mxc/mxcfb_hx8363_wvga.c, do the following changes
 #define TC358763_DCS_write_1A_3P(addr, ...)	\
 	TC358763_DCS_write_1A_nP(3, addr, __VA_ARGS__)
 
+#define TC358763_DCS_write_1A_4P(addr, ...)	\
+	TC358763_DCS_write_1A_nP(4, addr, __VA_ARGS__)
+
 #define TC358763_DCS_write_1A_5P(addr, ...)	\
 	TC358763_DCS_write_1A_nP(5, addr, __VA_ARGS__)
 
 #define TC358763_DCS_write_1A_7P(addr, ...)	\
 	TC358763_DCS_write_1A_nP(7, addr, __VA_ARGS__)
 
+#define TC358763_DCS_write_1A_11P(addr, ...)	\
+	TC358763_DCS_write_1A_nP(11, addr, __VA_ARGS__)
+
 #define TC358763_DCS_write_1A_12P(addr, ...)	\
 	TC358763_DCS_write_1A_nP(12, addr, __VA_ARGS__)
 
 #define TC358763_DCS_write_1A_14P(addr, ...)	\
 	TC358763_DCS_write_1A_nP(14, addr, __VA_ARGS__)
 
+#define TC358763_DCS_write_1A_16P(addr, ...)	\
+	TC358763_DCS_write_1A_nP(16, addr, __VA_ARGS__)
+
 #define TC358763_DCS_write_1A_19P(addr, ...)	\
 	TC358763_DCS_write_1A_nP(19, addr, __VA_ARGS__)
 
 
 static struct fb_videomode truly_lcd_modedb[] = {

-	dev_dbg(&mipi_dsi->pdev->dev, "MIPI DSI LCD HX8363 setup.\n");
-
-	TC358763_DCS_write_1A_3P(0xB9,0xFF,0x83,0x63);/* SET password */
-
-	TC358763_DCS_write_1A_19P(0xB1,0x01,0x00,0x44,0x08,0x01,0x10,0x10,0x36,
-				  0x3E,0x1A,0x1A,0x40,0x12,0x00,0xE6,0xE6,0xE6,0xE6,0xE6);/* Set Power */
-	TC358763_DCS_write_1A_2P(0xB2,0x08,0x03);/* Set DISP */
-	TC358763_DCS_write_1A_7P(0xB4,0x02,0x18,0x9C,0x08,0x18,0x04,0x6C);
-	TC358763_DCS_write_1A_1P(0xB6,0x00);/* Set VCOM */
-	TC358763_DCS_write_1A_1P(0xCC,0x0B);/* Set Panel */
-	TC358763_DCS_write_1A_34P(0xE0,0x0E,0x15,0x19,0x30,0x31,0x3F,0x27,0x3C,0x88,0x8F,0xD1,0xD5,0xD7,0x16,0x16,
-				  0x0C,0x1E,0x0E,0x15,0x19,0x30,0x31,0x3F,0x27,0x3C,0x88,0x8F,
-				  0xD1,0xD5,0xD7,0x16,0x16,0x0C,0x1E);
-	mdelay(5);
-
-	TC358763_DCS_write_1A_1P(0x3A,0x77);/* 24bit */
-	TC358763_DCS_write_1A_14P(0xBA,0x11,0x00,0x56,0xC6,0x10,0x89,0xFF,0x0F,0x32,0x6E,0x04,0x07,0x9A,0x92);
-	TC358763_DCS_write_1A_0P(0x21);
+	dev_info(&mipi_dsi->pdev->dev, "MIPI DSI LCD HX8363 setup.\n");
 
+	TC358763_DCS_write_1A_5P(0xFF,0x77,0x01,0x00,0x00,0x13);
+	TC358763_DCS_write_1A_2P(0xE8,0x00,0x0E);
+	TC358763_DCS_write_1A_5P(0xFF,0x77,0x01,0x00,0x00,0x00);
 	TC358763_DCS_write_1A_0P(0x11);
-	msleep(10);
-
+	mdelay(120);
+	TC358763_DCS_write_1A_5P(0xFF,0x77,0x01,0x00,0x00,0x13);
+	TC358763_DCS_write_1A_2P(0xE8,0x00,0x0C);
+	mdelay(10);
+	TC358763_DCS_write_1A_2P(0xE8,0x00,0x00);
+	TC358763_DCS_write_1A_5P(0xFF,0x77,0x01,0x00,0x00,0x00);
+	TC358763_DCS_write_1A_5P(0xFF,0x77,0x01,0x00,0x00,0x10);
+	TC358763_DCS_write_1A_2P(0xC0,0x4F,0x00);
+	TC358763_DCS_write_1A_2P(0xC1,0x07,0x02);
+	TC358763_DCS_write_1A_2P(0xC2,0x31,0x05);
+	TC358763_DCS_write_1A_1P(0xC6,0x01);
+	TC358763_DCS_write_1A_1P(0xCC,0x38);
+	TC358763_DCS_write_1A_16P(0xB0,0x00,0x0A,0x11,0x0C,0x10,0x05,0x00,0x08,0x08,0x1F,0x07,0x13,0x10,0xA9,0x30,0x18);
+	TC358763_DCS_write_1A_16P(0xB1,0x00,0x0B,0x11,0x0D,0x0F,0x05,0x02,0x07,0x06,0x20,0x05,0x15,0x13,0xA9,0x30,0x18);
+	TC358763_DCS_write_1A_5P(0xFF,0x77,0x01,0x00,0x00,0x11);
+	TC358763_DCS_write_1A_1P(0xB0,0x53);
+	TC358763_DCS_write_1A_1P(0xB1,0x60);
+	TC358763_DCS_write_1A_1P(0xB2,0x87);
+	TC358763_DCS_write_1A_1P(0xB3,0x80);
+	TC358763_DCS_write_1A_1P(0xB5,0x49);
+	TC358763_DCS_write_1A_1P(0xB7,0x85);
+	TC358763_DCS_write_1A_1P(0xB8,0x21);
+	TC358763_DCS_write_1A_1P(0xC1,0x78);
+	TC358763_DCS_write_1A_1P(0xC2,0x78);
+	mdelay(100);
+
+	TC358763_DCS_write_1A_3P(0xE0,0x00,0x00,0x02);
+	TC358763_DCS_write_1A_11P(0xE1,0x03,0xA0,0x00,0x00,0x02,0xA0,0x00,0x00,0x00,0x33,0x33);
+	TC358763_DCS_write_1A_12P(0xE2,0x22,0x22,0x33,0x33,0x88,0xA0,0x00,0x00,0x87,0xA0,0x00,0x00);
+	TC358763_DCS_write_1A_4P(0xE3,0x00,0x00,0x22,0x22);
+	TC358763_DCS_write_1A_2P(0xE4,0x44,0x44);
+	TC358763_DCS_write_1A_16P(0xE5,0x04,0x84,0xA0,0xA0,0x06,0x86,0xA0,0xA0,0x08,0x88,0xA0,0xA0,0x0A,0x8A,0xA0,0xA0);
+	TC358763_DCS_write_1A_4P(0xE6,0x00,0x00,0x22,0x22);
+	TC358763_DCS_write_1A_2P(0xE7,0x44,0x44);
+	TC358763_DCS_write_1A_16P(0xE8,0x03,0x83,0xA0,0xA0,0x05,0x86,0xA0,0xA0,0x07,0x87,0xA0,0xA0,0x09,0x89,0xA0,0xA0);
+	TC358763_DCS_write_1A_7P(0xEB,0x00,0x01,0xE4,0xE4,0x88,0x00,0x40);
+	TC358763_DCS_write_1A_2P(0xEC,0x3C,0x01);
+	TC358763_DCS_write_1A_16P(0xED,0xAB,0x89,0x76,0x54,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x20,0x45,0x67,0x98,0xBA);
+	TC358763_DCS_write_1A_6P(0xEF,0x08,0x08,0x08,0x08,0x3F,0x1F);
+	TC358763_DCS_write_1A_5P(0xFF,0x77,0x01,0x00,0x00,0x00);
+	mdelay(20);
 	TC358763_DCS_write_1A_0P(0x29);
-	msleep(120);
+
 
 	return 0;
 }


5. Basically, these changes will make it work but not properly fit the screen. 
But will will have a working LCD. You then need to change bit-per-pixel, type of color i.e ABGR32 or RGB888 and also the resolution of the screen.

6. modify the kernel_imx/drivers/video/fbdev/mxc/mxcfb_hx8363_wvga.c
It seems like the information of the LCD resolution has been hard coded in this file. 

 static struct fb_videomode truly_lcd_modedb[] = {
 	{
-		ACTIVE_HIGH_NAME, 50, 480, 854, 41042,
-		40, 60,
-		3, 3,
-		8, 4,
+		ACTIVE_HIGH_NAME, 0, 480, 640, 47619,
+		40, 20,
+		100, 100,
+		10, 2,
 		0x0,
 		FB_VMODE_NONINTERLACED,
 		0,
 	}, {
-		ACTIVE_LOW_NAME, 50, 480, 854, 41042,
-		40, 60,
-		3, 3,
-		8, 4,
+		ACTIVE_LOW_NAME, 60, 480, 640, 47619,
+		40, 20,
+		100, 100,
+		10, 2,
 		FB_SYNC_OE_LOW_ACT,
 		FB_VMODE_NONINTERLACED,
 		0,

7. To flip the orientation of Android screen, modify, frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java 

private boolean mForceDefaultOrientation = false;
    int mUserRotationMode = WindowManagerPolicy.USER_ROTATION_FREE;
 -  int mUserRotation = Surface.ROTATION_0;
 +  int mUserRotation = Surface.ROTATION_270;
    boolean mAccelerometerDefault;
 
    +    if (true) {
    +        return Surface.ROTATION_270;
    +    }
        if (mForceDefaultOrientation) {
            return Surface.ROTATION_0;
        }
        synchronized (mLock) {


8. Lastly, we need to tweak the dpr device pixel ratio, physical vs logical pixel,
https://blog.specctr.com/pixels-physical-vs-logical-c84710199d62

This can be done in /services/core/java/com/android/server/display/LogicalDisplay.java

 	    mBaseDisplayInfo.uniqueId = deviceInfo.uniqueId;
            mBaseDisplayInfo.appWidth = deviceInfo.width;
            mBaseDisplayInfo.appHeight = deviceInfo.height;
-           mBaseDisplayInfo.logicalWidth = deviceInfo.width;
+           mBaseDisplayInfo.logicalWidth = 360;//deviceInfo.width;
            mBaseDisplayInfo.logicalHeight = deviceInfo.height;
            mBaseDisplayInfo.rotation = Surface.ROTATION_0;
            mBaseDisplayInfo.modeId = deviceInfo.modeId;












